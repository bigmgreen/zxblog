# 写在最前面

- 今天要跟大家分享的知识点名叫：*尾递归调用*，先知道个名儿，读下去知其意

## 问题

- 当在一个函数中调用另一个函数时，系统会重新分配一个*栈帧*来保持调用函数的所有状态，这个过程会格外耗费处理时间和增加额外的内存
- 当我们进行*递归*编程时（函数重复调用自己或者多个函数相互调用形成*递归*），调用栈的深度很容易达到成百上千，如果任由其增长，很快计算机就会陷入瘫痪...
- 这个时候 js 引擎不得不采用一个武断的措施来防止上述情况的发生，这也就是为什么会看到*RangeError：Maximum call stack exceeded* 的原因，如图：
  
  ![RangeError](./rangeerror.jpg)

## 尾调用

- *尾调用*的概念非常简单，是指某个函数的最后一步是调用另一个函数，它可以以避免额外分配*栈帧*的方式对函数调用进行优化
- 具体操作就是定义一个 `return` 函数调用的语句，除了调用后返回函数返回值以外其值没有任何多余操作
- 先来一个不是*尾调用*的函数调用，代码如下：

```js
"use strict"

function foo(x) {
  return x *2;
}

function bar(x) {
  return 1 + foo(x);
}

bar(10); // 21
```

- 可以看到在 `foo(x)` 执行完成后有执行了 `+ 1` 操作，所以 `bar(..)` 的调用状态需要被保留

- *尾调用*不是一定要出现在函数尾部，只要保证是最后一步操作就可以，代码如下：

```js
"use strict"

function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

## 尾调用优化

- 我们都知道函数调用会在内存中形成一个调用*调用帧*，多个*调用帧*就会组成*调用栈*，这个*调用栈*就是我们需要进行优化的地方
- 使*尾调用*为函数调用最后一步操作，这样就可以让内存不再保留外层函数的*调用帧*、直接复用内层函数的*调用帧*
- 这种优化方式就是*尾调用优化*，即复用内层函数的*调用帧*
- 如果所有函数都使用*尾调用*，那么每次执行时，*调用帧*始终保持单一，这会节省大量内存

- 来看个例子：

```js
function foo(x) {
  return x * 3;
}

function bar(x) {
  x = x + 1;
  if (x < 10) {
    return bar(x + 2);
  } else {
    return foo(x);
  }
}

bar(5); // 36
bar(10); // 33
```

- 上面代码一个是*递归（bar）*，一个*是普通函数（foo）*，他们的调用位置都处在一个*合适的位置（proper tail position，简称 PTC）*，在调用执行完成后，所做的操作只是 `return`
- PTC 是可以被优化的，优化操作就称作*尾调用优化（Tail Call Optimization，简称 TCO）*
- 函数经过 TCO 以后，在执行时是就不需要额外再分配*栈帧*，只复用当前的*栈帧*即可，这就意味着对*调用栈*的深度将没有任何限制条件，使在真实环境中使用*递归*成为可能
- 对于 es6 来说，无论是否递归，PTC 都应该进行 TCO，并且在 ES6 规范中明确规定，ECMAScript 的所有实现，都必须采取 TCO

## 尾递归调用

- 我想最容易发生*栈溢出 错误（stack overflow）*的操作大概就是*递归*了，因为它在执行过程中会创建非常多的*栈帧*，以至于消耗很多内存
- 但我们可以采用 TCO 来解决这个问题，确保在运行过程中不会发生*栈溢出 错误（stack overflow）*

- 反例代码如下：

```js
function foo(x) {
  if (x === 2) return 10;
  return x * foo(x - 2);
}

foo(6) // 240
```

- 上面代码会创建多个*调用帧*，复杂度为 *O(n)*

- 如果采用 TCO，由于只有一个*调用栈*，则复杂度为 *O(1)*，代码如下：

```js
function foo(x, y) {
  if (x === 2) return y;
  return foo(x - 2, x * y);
}

foo(6, 10); // 240
```

## 尾递归重写

- 当我们遇到不是以 PTC 方式编写的函数，那么就需要重新设计其结构了，代码如下：

```js
function foo(x) {
  if (x <= 1) return 1;
  return (x / 2) + foo(x--);
}

foo(2323)
```

- 由于 *foo* 的每次都要在结果 `return` 之前 `* (x + 5)`，所以*foo* 不是 PTC

- 现在我们来把它重新，以适合 ES6 引擎，代码如下：

```js
var foo = (function() {
  function _foo(acc, x) {
    if (x <= 1) return acc;
    return _foo( (x / 2) + acc, x--);
  }

  return function(x) {
    return _foo(1, x);
  }
})();

foo(123456)
```

- 上面代码如果在实现了 TCO 的引擎中运行会得到正确结果，否则仍然是 *RangeError*

## 总结

- TOC 是一个非常好的代码性能优化点，希望大家掌握，虽然 TOC 不是所有环境都支持，但是掌握这个思想还是对我有很大帮助
- TCO 让我们不再把递归作为理论方案，而可以将其运用到实际的 JavaScript 中了
